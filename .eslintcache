[{"/Users/kaybanks/Repository/videoplayer/src/App.js":"1","/Users/kaybanks/Repository/videoplayer/src/index.js":"2"},{"size":29122,"mtime":1633740290168,"results":"3","hashOfConfig":"4"},{"size":478,"mtime":1633735875195,"results":"5","hashOfConfig":"4"},{"filePath":"6","messages":"7","errorCount":0,"warningCount":7,"fixableErrorCount":0,"fixableWarningCount":0,"source":"8"},"149wjm3",{"filePath":"9","messages":"10","errorCount":0,"warningCount":0,"fixableErrorCount":0,"fixableWarningCount":0},"/Users/kaybanks/Repository/videoplayer/src/App.js",["11","12","13","14","15","16","17"],"import './App.css'\n\nimport React, { Component } from 'react'\nimport {\n    convertToNearest30,\n    convertToNearestX,\n    getVideoSplitFactor,\n    toMinutesSeconds\n} from './utility/index'\n\nimport Duration from './utility/Duration'\nimport FlashMessage from './player/notify'\nimport ReactPlayer from 'react-player'\nimport Toolbar from './components/toolbar'\nimport Volume from './components/volume'\nimport { findDOMNode } from 'react-dom'\nimport { hot } from 'react-hot-loader'\nimport screenfull from 'screenfull'\n\nclass App extends Component {\n    state = {\n        url: 'https://www.youtube.com/watch?v=oUFJJNQGwhk',\n        pip: false,\n        playing: true,\n        controls: true,\n        light: false,\n        volume: 0.8,\n        muted: true,\n        played: 0,\n        loaded: 0,\n        duration: 0,\n        currentTime: 0,\n        playbackRate: 5.0,\n        loop: false,\n        //  ======================\n        message: { colorMessage: '', mainMessage: '' },\n        playlist: [],\n        repeatMode: 'repeat-all',\n        currentlyPlaying: '',\n        title: '',\n        videoFormat: '',\n        reviewModeSate: false,\n        reviewRangeStart: 0,\n        reviewRangeEnd: 0,\n        trackingModeState: 'inactive'\n        //  ===================\n    }\n\n    handlePlayPause = () => {\n        this.setState({ playing: !this.state.playing })\n    }\n\n    handleStop = () => {\n        this.setState({ url: null, playing: false })\n    }\n\n    handleSetPlaybackRate = e => {\n        this.setState({ playbackRate: parseFloat(e.target.value) })\n    }\n\n    setSpeed = value => {\n        this.setState({ playbackRate: parseFloat(value) })\n    }\n\n    setVideoPosition = value => {\n        this.setState({ currentTime: parseFloat(value) })\n    }\n\n    handlePrevious = (_, playableUniqueID) => {\n        let currentlyPlaying\n        let currentlyPlayingIndex\n        let newCurrentlyPlayingOBJ\n\n        if (playableUniqueID) {\n            currentlyPlaying = playableUniqueID\n            currentlyPlayingIndex = this.state.playlist.findIndex(\n                item => item.id === currentlyPlaying\n            )\n        } else {\n            currentlyPlaying = this.state.currentlyPlaying\n            currentlyPlayingIndex = this.state.playlist.findIndex(\n                item => item.id === currentlyPlaying\n            )\n            currentlyPlayingIndex--\n        }\n\n        if (currentlyPlayingIndex <= 0) {\n            currentlyPlayingIndex = this.state.playlist.length - 1\n        }\n\n        newCurrentlyPlayingOBJ = this.state.playlist[currentlyPlayingIndex]\n\n        const playingType = newCurrentlyPlayingOBJ['type']\n\n        if (playingType === 'separator') {\n            const nextPlayableIndex = currentlyPlayingIndex - 1\n            const nextPlayableIndexOBJ = this.state.playlist[nextPlayableIndex]\n            const playableUniqueID = nextPlayableIndexOBJ['id']\n\n            return this.handlePrevious(null, playableUniqueID)\n        }\n\n        const newCurrentlyPlaying = newCurrentlyPlayingOBJ['id']\n\n        this.setCurrentlyPlaying(newCurrentlyPlaying, newCurrentlyPlayingOBJ)\n    }\n\n    handleNext = (_, playableUniqueID) => {\n        let currentlyPlaying\n        let currentlyPlayingIndex\n        let newCurrentlyPlayingOBJ\n\n        if (playableUniqueID) {\n            currentlyPlaying = playableUniqueID\n            currentlyPlayingIndex = this.state.playlist.findIndex(\n                item => item.id === currentlyPlaying\n            )\n        } else {\n            currentlyPlaying = this.state.currentlyPlaying\n            currentlyPlayingIndex = this.state.playlist.findIndex(\n                item => item.id === currentlyPlaying\n            )\n            currentlyPlayingIndex++\n        }\n\n        if (currentlyPlayingIndex >= this.state.playlist.length - 1) {\n            currentlyPlayingIndex = 0\n        }\n\n        newCurrentlyPlayingOBJ = this.state.playlist[currentlyPlayingIndex]\n\n        const playingType = newCurrentlyPlayingOBJ['type']\n\n        if (playingType === 'separator') {\n            const nextPlayableIndex = currentlyPlayingIndex + 1\n            const nextPlayableIndexOBJ = this.state.playlist[nextPlayableIndex]\n            const playableUniqueID = nextPlayableIndexOBJ['id']\n\n            return this.handleNext(null, playableUniqueID)\n        }\n\n        const newCurrentlyPlaying = newCurrentlyPlayingOBJ['id']\n\n        this.setCurrentlyPlaying(newCurrentlyPlaying, newCurrentlyPlayingOBJ)\n    }\n\n    handlePause = () => {\n        //  console.log('onPause')\n        this.setState({ playing: false })\n    }\n\n    handlePlay = () => {\n        this.setState({ playing: true })\n        console.log('onPlay')\n    }\n\n    handleError = error => {\n        this.handleNext()\n        console.log('ðŸš€ ~ file: App.js ~ line 169 ~ App ~ error', error)\n    }\n\n    handleEnded = () => {\n        const currentlyPlaying = this.state.currentlyPlaying\n\n        const currentlyPlayingIndex = this.state.playlist.findIndex(\n            item => item.id === currentlyPlaying\n        )\n        const newCurrentlyPlayingOBJ = this.state.playlist[\n            currentlyPlayingIndex + 1\n        ]\n\n        let newCurrentlyPlaying = newCurrentlyPlayingOBJ['id']\n\n        if (currentlyPlayingIndex + 1 <= this.state.playlist.length - 1) {\n            this.setCurrentlyPlaying(\n                newCurrentlyPlaying,\n                newCurrentlyPlayingOBJ,\n                1000\n            )\n        } else {\n            if (this.state.repeatMode === 'repeat-all') {\n                const firstItemOBJ = this.state.playlist[0]\n\n                newCurrentlyPlaying = firstItemOBJ['id']\n                this.setCurrentlyPlaying(\n                    newCurrentlyPlaying,\n                    newCurrentlyPlayingOBJ,\n                    1000\n                )\n            } else if (this.state.repeatMode === 'repeat-one') {\n                this.setCurrentlyPlaying(\n                    currentlyPlaying,\n                    newCurrentlyPlayingOBJ,\n                    1000\n                )\n            }\n        }\n\n        console.log('onEnded\": ', this.state)\n        //  this.setState({ playing: this.state.loop })\n    }\n\n    setCurrentlyPlayingPublic = (uniqueId, callback = () => {}) => {\n        console.log('ðŸš€ ~ file: App.js ~ line 166 ~ App ~ uniqueId', uniqueId)\n\n        const chosenItemIndex = this.state.playlist.findIndex(\n            item => item.id === uniqueId\n        )\n\n        const chosenItemItemOBJ = this.state.playlist[chosenItemIndex]\n        const playingType = chosenItemItemOBJ['type']\n\n        if (playingType === 'separator') {\n            const nextPlayableIndex = chosenItemIndex + 1\n            const nextPlayableIndexOBJ = this.state.playlist[nextPlayableIndex]\n            const playableUniqueID = nextPlayableIndexOBJ['id']\n\n            this.setCurrentlyPlayingPublic(playableUniqueID)\n        }\n\n        this.setCurrentlyPlaying(uniqueId, chosenItemItemOBJ, callback)\n    }\n\n    setCurrentlyPlaying = (\n        uniqueId,\n        currentlyPlayingOBJ,\n        callback = () => {}\n    ) => {\n        this.setState(\n            {\n                url: currentlyPlayingOBJ.path,\n                currentlyPlaying: uniqueId,\n                playing: true\n            },\n            () => {\n                callback()\n            }\n            // console.error('ðŸš€ ðŸš€ ðŸš€ currentlyPlaying: ', this.state)\n        )\n    }\n\n    setPlaylist = (items = [], callback) => {\n        if (!items.length) return\n\n        const currentPlaylist = this.state.playlist\n        const newPlaylist = [...currentPlaylist, ...items]\n        let index = 0\n        let nextItemToPlay = items[index]\n\n        while (nextItemToPlay?.type === 'separator') {\n            nextItemToPlay = items[index]\n            index = index + 1\n        }\n\n        const currentlyPlaying = newPlaylist.find(\n            item => item.id === nextItemToPlay.id\n        )\n\n        this.setState(\n            {\n                playlist: newPlaylist,\n                currentlyPlaying: currentlyPlaying.id,\n                url: nextItemToPlay?.path,\n                playing: true\n            },\n            callback()\n        )\n    }\n\n    load = url => {\n        this.setState({\n            url,\n            played: 0,\n            loaded: 0,\n            pip: false\n        })\n    }\n\n    handleDuration = duration => {\n        //  console.log('onDuration', duration)\n        this.setState({ duration })\n    }\n\n    handleToggleControls = () => {\n        const url = this.state.url\n\n        this.setState(\n            {\n                controls: !this.state.controls,\n                url: null\n            },\n            () => this.load(url)\n        )\n    }\n\n    handleToggleLight = () => {\n        this.setState({ light: !this.state.light })\n    }\n\n    handleToggleLoop = () => {\n        this.setState({ loop: !this.state.loop })\n    }\n\n    handleVolumeChange = e => {\n        this.setState({ volume: parseFloat(e.target.value) })\n    }\n\n    handleToggleMuted = () => {\n        this.setState({ muted: !this.state.muted })\n    }\n\n    handleTogglePIP = () => {\n        this.setState({ pip: !this.state.pip })\n    }\n\n    handleEnablePIP = () => {\n        //  console.log('onEnablePIP')\n        this.setState({ pip: true })\n    }\n\n    handleDisablePIP = () => {\n        //  console.log('onDisablePIP')\n        this.setState({ pip: false })\n    }\n\n    handleSeekMouseDown = e => {\n        this.setState({ seeking: true })\n    }\n\n    handleSeekChange = e => {\n        this.setState({ played: parseFloat(e.target.value) })\n    }\n\n    handleSeekMouseUp = e => {\n        this.setState({ seeking: false })\n        this.player.seekTo(parseFloat(e.target.value))\n    }\n\n    handleProgress = state => {\n        //  console.log('onProgress', state)\n\n        // We only want to update time slider if we are not currently seeking\n        if (!this.state.seeking) {\n            this.setState(state)\n        }\n    }\n\n    handleClickFullscreen = () => {\n        screenfull.request(findDOMNode(this.player))\n    }\n\n    renderLoadButton = (url, label) => {\n        return <button onClick={() => this.load(url)}>{label}</button>\n    }\n\n    ref = player => {\n        this.player = player\n    }\n\n    notify = ({ mainMessage, colorMessage }) => {\n        this.setState({ message: { mainMessage, colorMessage } })\n    }\n\n    style = {\n        position: 'absolute',\n        left: '-886px',\n        height: '300px',\n        width: '250px',\n        background: ' #a58181'\n    }\n    // ==========================================================\n    // ==========================================================\n\n    replayConfig = {\n        startPosition: 0,\n        endPosition: 120,\n        unsubscribe: null,\n        defaultStartOffset: 30,\n        defaultEndOffset: 120,\n        startOffset: 30,\n        interval: 120,\n        cachedPlaybackRate: 2.0\n    }\n\n    alertConfig = {\n        alertConfigMidwayTime: null,\n        alertConfigOneThirdTime: null,\n        alertConfigTwoThirdTime: null,\n        speedMode: 0, //1\n        lastKeypressTime: null,\n        delta: 500\n    }\n\n    studyStatisticsTracker = (increment = 1) => {\n        const currentSplit = parseInt(\n            this.replayConfig.endPosition / this.replayConfig.interval\n        )\n\n        let reviews = JSON.parse(localStorage.getItem('reviews'))\n        const reviewExists = !!reviews\n        let updatedReview = reviewExists ? reviews : {}\n        let review = updatedReview[this.state.url]\n\n        if (!review) {\n            review = {\n                name: this.state.title,\n                path: this.state.url,\n                type: this.state.videoFormat,\n                replayHistory: {\n                    [`split-${currentSplit}`]: {\n                        count: increment,\n                        startTime: this.replayConfig.startPosition,\n                        endTime: this.replayConfig.endPosition\n                    }\n                },\n                lastReviewDate: Date.now()\n            }\n        } else {\n            if (!review.replayHistory[`split-${currentSplit}`]) {\n                review.replayHistory[`split-${currentSplit}`] = {\n                    count: increment,\n                    startTime: this.replayConfig.startPosition,\n                    endTime: this.replayConfig.endPosition\n                }\n            } else {\n                review.replayHistory[`split-${currentSplit}`].count =\n                    review.replayHistory[`split-${currentSplit}`].count +\n                    increment\n            }\n\n            review.lastReviewDate = Date.now()\n        }\n\n        updatedReview[this.state.url] = { ...review }\n        localStorage.setItem('reviews', JSON.stringify({ ...updatedReview }))\n        this.notifyReplayStatus()\n    }\n\n    setupForStandardTrackingMode = () => {\n        if (this.state.reviewModeSate !== 'inactive') {\n            this.setState({ reviewModeSate: 'inactive' })\n            this.setupReviewMode({ activate: false })\n        }\n\n        let videoSplit = getVideoSplitFactor(this.state.duration)\n\n        this.replayConfig.interval = parseInt(this.state.duration / videoSplit)\n        this.replayConfig.startOffset = convertToNearestX(\n            this.state.currentTime,\n            this.replayConfig.interval\n        )\n    }\n\n    speedTracker = 2\n    trackingMode = (offSet, renormalize = true) => {\n        clearInterval(this.alertConfig.alertConfigMidwayTime)\n        clearInterval(this.alertConfig.alertConfigTwoThirdTime)\n        clearInterval(this.alertConfig.alertConfigOneThirdTime)\n        //   ========================\n\n        if (this.replayConfig.unsubscribe) {\n            clearInterval(this.replayConfig.unsubscribe)\n            this.replayConfig.unsubscribe = null\n            this.notify({\n                mainMessage: 'Replay: Stopped!',\n                colorMessage: 'rtrhfgfdhfghf'\n            })\n        } else {\n            if (renormalize) {\n                this.replayConfig.startPosition = Math.max(\n                    convertToNearest30(this.state.currentTime) - offSet,\n                    0\n                )\n\n                this.replayConfig.endPosition = Math.min(\n                    this.replayConfig.startPosition + offSet,\n                    this.state.duration\n                )\n            } else {\n                this.replayConfig.startPosition = Math.max(\n                    this.replayConfig.startOffset,\n                    0\n                )\n\n                this.replayConfig.endPosition = Math.min(\n                    this.replayConfig.startPosition +\n                        this.replayConfig.interval,\n                    this.state.duration\n                )\n            }\n\n            this.setSpeed(2)\n\n            const minDurationForVideoSplitFactor = 5 * 60\n\n            this.state.duration < minDurationForVideoSplitFactor\n                ? this.setVideoPosition(0)\n                : this.setVideoPosition(\n                      parseInt(this.replayConfig.startPosition)\n                  )\n\n            this.replayConfig.unsubscribe = setInterval(() => {\n                if (\n                    this.state.currentTime >=\n                        this.replayConfig.endPosition - 5 ||\n                    this.state.currentTime < this.replayConfig.startPosition\n                ) {\n                    this.setVideoPosition(this.replayConfig.startPosition)\n\n                    const speedTOptions = [2, 3, 10]\n\n                    this.speedTracker =\n                        (this.speedTracker + 1) % speedTOptions.length\n                    this.setSpeed(speedTOptions[this.speedTracker])\n                    this.studyStatisticsTracker()\n                }\n            }, 1000)\n            this.notifyReplayStatus()\n        }\n    }\n\n    alertAtKeyMoments = () => {\n        clearInterval(this.alertConfig.alertConfigMidwayTime)\n        clearInterval(this.alertConfig.alertConfigTwoThirdTime)\n        clearInterval(this.alertConfig.alertConfigOneThirdTime)\n        this.alertConfig.speedMode === 1 && this.setSpeed(2.5)\n        this.alertConfig.speedMode === 2 && this.setSpeed(2.5)\n        //   =================\n        //   const standardLength = 10 * 60; //10mins\n        //   const minimumLength = 6 * 60; //6mins\n        //   if (this.state.duration < minimumLength) return;\n        //   =================>\n        this.alertConfig.alertConfigOneThirdTime = setInterval(() => {\n            const _25PercentTime = this.state.duration * 0.25 //80%\n\n            if (\n                // this.state.duration > standardLength &&\n                this.state.currentTime > _25PercentTime &&\n                this.state.currentTime < _25PercentTime * 2\n            ) {\n                this.alertConfig.speedMode === 1 && this.setSpeed(3)\n                this.alertConfig.speedMode === 2 && this.setSpeed(3.5)\n\n                const remainTime = this.state.duration - _25PercentTime //25%\n\n                this.notify({\n                    mainMessage: `Alert:\\r\\nJust Past 25%`,\n                    colorMessage: `\\r\\n[${toMinutesSeconds(remainTime, false)}]`\n                })\n                clearInterval(this.alertConfig.alertConfigOneThirdTime)\n            }\n        }, 2000)\n\n        //   =================>\n        this.alertConfig.alertConfigMidwayTime = setInterval(() => {\n            const midwayTime = this.state.duration * 0.5 //60%\n\n            if (this.state.currentTime > midwayTime) {\n                this.alertConfig.speedMode === 1 && this.setSpeed(3)\n                this.alertConfig.speedMode === 2 && this.setSpeed(4)\n\n                const remainTime = this.state.duration - midwayTime //40%\n\n                this.notify({\n                    mainMessage: `Alert:\\r\\nJust Past 50%`,\n                    colorMessage: `\\r\\n[${toMinutesSeconds(remainTime, false)}]`\n                })\n                clearInterval(this.alertConfig.alertConfigMidwayTime)\n            }\n        }, 2000)\n\n        //   =====================>\n        this.alertConfig.alertConfigTwoThirdTime = setInterval(() => {\n            const _75PercentTime = this.state.duration * 0.75 //80%\n\n            if (\n                // this.state.duration > standardLength &&\n                this.state.currentTime > _75PercentTime\n            ) {\n                this.alertConfig.speedMode === 1 && this.setSpeed(3.5)\n                this.alertConfig.speedMode === 2 && this.setSpeed(4.5)\n\n                const remainTime = this.state.duration - _75PercentTime //25%\n\n                this.notify({\n                    mainMessage: `Alert:\\r\\nJust Past 75%`,\n                    colorMessage: `\\r\\n[${toMinutesSeconds(remainTime, false)}]`\n                })\n                clearInterval(this.alertConfig.alertConfigTwoThirdTime)\n            }\n        }, 2000)\n    }\n\n    //   moveToNextPlaybackRange = () => {\n    //     this.replayConfig.startPosition = Math.min(\n    //       this.replayConfig.startPosition + this.replayConfig.interval,\n    //       this.state.duration - this.replayConfig.interval\n    //     )\n    //     this.replayConfig.endPosition = Math.min(\n    //       this.replayConfig.startPosition + this.replayConfig.interval,\n    //       this.state.duration\n    //     )\n    //     this.setVideoPosition(this.replayConfig.startPosition)\n    //     this.notifyReplayStatus()\n    //   }\n\n    //   moveToPreviousPlaybackRange = () => {\n    //     this.replayConfig.startPosition = Math.max(\n    //       this.replayConfig.startPosition - this.replayConfig.interval,\n    //       0\n    //     )\n    //     this.replayConfig.endPosition = Math.min(\n    //       this.replayConfig.startPosition + this.replayConfig.interval,\n    //       this.state.duration\n    //     )\n    //     this.setVideoPosition(this.replayConfig.startPosition)\n    //     this.notifyReplayStatus()\n    //   }\n\n    isReviewing = false\n    unsubscribeToReview = null\n\n    setupReviewMode = ({ activate = true, loopCurrentSplit = false }) => {\n        const deactivate = !activate\n\n        if (deactivate) {\n            clearInterval(this.unsubscribeToReview)\n\n            return this.notify({\n                mainMessage: 'Replay: Stopped!',\n                colorMessage: ''\n            })\n        }\n\n        if (this.state.trackingModeState === 'active') {\n            this.setState({ trackingModeState: 'inactive' })\n            this.trackingMode(null, false)\n        }\n\n        if (this.state.reviewRangeStart)\n            this.setVideoPosition(this.state.reviewRangeStart)\n\n        clearInterval(this.unsubscribeToReview)\n        loopCurrentSplit &&\n            this.notify({\n                mainMessage: `Reviews: Looping`,\n                colorMessage: ''\n            })\n        this.watcherForReviewMode(loopCurrentSplit)\n    }\n\n    watcherForReviewMode = (loopCurrentSplit = false) => {\n        this.unsubscribeToReview = setInterval(() => {\n            if (this.state.currentTime < this.state.reviewRangeStart) {\n                this.setVideoPosition(this.state.reviewRangeStart)\n            }\n\n            if (loopCurrentSplit) {\n                if (this.state.currentTime >= this.state.reviewRangeEnd - 5) {\n                    this.setVideoPosition(this.state.reviewRangeStart)\n                    this.studyStatisticsTracker(0.5)\n                }\n            } else {\n                if (this.state.currentTime >= this.state.reviewRangeEnd - 5) {\n                    this.studyStatisticsTracker(0.25)\n                    // todo ========\n                    this.setCurrentlyPlaying(\n                        this.state.playlist[this.state.currentlyPlaying + 1]\n                    )\n\n                    this.setState({\n                        currentlyPlaying: this.state.currentlyPlaying + 1\n                    })\n                    this.setVideoPosition(this.state.reviewRangeStart)\n                    //  ========\n                    clearInterval(this.unsubscribeToReview)\n                    this.watcherForReviewMode()\n                    // ===================\n                    //  this.setVideoPosition(this.state.reviewRangeStart);\n                    //  this.setSpeed(speedTOptions[this.speedTracker]);\n                    //  studyStatisticsTracker();\n                    //   this.notifyReplayStatus();\n                }\n            }\n        }, 1000)\n    }\n\n    // video.addEventListener('seeked', this.alertAtKeyMoments);\n    videoOnLoadeddata = () => {\n        //   clearInterval(this.replayConfig.unsubscribe);\n        this.alertAtKeyMoments()\n\n        //   setupForStandardTrackingMode();\n        //   this.this.trackingMode(null, false);\n        //   setTimeout(this.notifyReplayStatus, 5000);\n\n        if (this.replayConfig.unsubscribe) {\n            this.replayConfig.unsubscribe = null\n            this.setupForStandardTrackingMode()\n            this.trackingMode(null, false)\n\n            return setTimeout(this.notifyReplayStatus, 5000)\n        }\n\n        const videoTitle = `${this.state.title}  `\n\n        this.notify({\n            mainMessage: videoTitle,\n            colorMessage: `[${toMinutesSeconds(this.state.duration)}]`\n        })\n    }\n\n    // video.addEventListener('timeupdate', detectBackwardSkipSeek);\n\n    videoOnPause = () => {\n        //   this.replayConfig.unsubscribe && studyStatisticsTracker(0.5);\n        this.studyStatisticsTracker(0.5)\n    }\n\n    videoOnended = () => {\n        if (this.replayConfig.unsubscribe) {\n            this.setVideoPosition(this.replayConfig.startPosition)\n            this.notifyReplayStatus()\n        }\n\n        //   this.setSpeed(this.replayConfig.cachedPlaybackRate || 3);\n\n        //   clearInterval(this.replayConfig.unsubscribe);\n        //   this.replayConfig = {};\n\n        this.notify({\n            mainMessage: `Toggle Speed Stopped:`,\n            colorMessage: ''\n        })\n    }\n\n    seekToTime = value => {\n        let seekToTime = this.state.currentTime + value\n\n        if (seekToTime < 0) {\n            this.setVideoPosition(0)\n        } else if (seekToTime > this.state.duration)\n            this.setVideoPosition(this.state.duration)\n\n        this.setVideoPosition(seekToTime)\n        this.notify({\n            mainMessage: `Current Position: <${toMinutesSeconds(\n                this.state.currentTime\n            )}> of <${toMinutesSeconds(this.state.duration)}>`,\n            colorMessage: ''\n        })\n    }\n\n    reduceSpeed = (value = 0.25) => {\n        const MIN_SPEED = 0.5\n        let newSpeed = this.state.playbackRate - value\n\n        newSpeed = newSpeed < MIN_SPEED ? MIN_SPEED : newSpeed\n        this.setSpeed(newSpeed)\n    }\n\n    increaseSpeed = (value = 0.25) => {\n        const MAX_SPEED = 15\n        let newSpeed = this.state.playbackRate + value\n\n        newSpeed = newSpeed > MAX_SPEED ? MAX_SPEED : newSpeed\n        this.setSpeed(newSpeed)\n    }\n\n    notifyReplayStatus = () => {\n        const currentSplit = parseInt(\n            this.replayConfig.endPosition / this.replayConfig.interval\n        )\n        const totalSplit = parseInt(\n            this.state.duration / this.replayConfig.interval\n        )\n\n        let reviews = JSON.parse(localStorage.getItem('reviews'))\n\n        let videoStat =\n            reviews &&\n            reviews[this.state.url]?.replayHistory[`split-${currentSplit}`]\n                ?.count\n\n        this.notify({\n            mainMessage: `Video Stats: Split watch count:: ${\n                videoStat ?? 0\n            } times!\n    \\r\\nReplay: is ${\n        this.replayConfig.unsubscribe ? 'ON!:' : 'OFF!:'\n    }\\r\\nStart Time: ${toMinutesSeconds(\n                this.replayConfig.startPosition\n            )}\\r\\nEnd Time:  ${toMinutesSeconds(\n                this.replayConfig.endPosition\n            )}`,\n            colorMessage: `\\r\\nPosition:   [${currentSplit}] of [${totalSplit}]`,\n            delay: 20000\n        })\n    }\n    // ==========================================================\n    // ==========================================================\n\n    render() {\n        const {\n            url,\n            playing,\n            controls,\n            light,\n            volume,\n            muted,\n            loop,\n            played,\n            loaded,\n            duration,\n            playbackRate,\n            pip\n        } = this.state\n\n        const SEPARATOR = ' Â· '\n        const turnOffSection = true\n\n        return (\n            <div className=\"app\">\n                <div className=\"player-wrapper\">\n                    <ReactPlayer\n                        ref={this.ref}\n                        className=\"react-player\"\n                        width=\"auto\"\n                        height=\"100vh\"\n                        url={url}\n                        pip={pip}\n                        playing={playing}\n                        controls={controls}\n                        light={light}\n                        loop={loop}\n                        playbackRate={playbackRate}\n                        volume={volume}\n                        muted={muted}\n                        onReady={() => {\n                            console.log('onReady')\n                            this.videoOnLoadeddata()\n                        }}\n                        onStart={() => {\n                            console.log('onStart')\n                        }}\n                        onPlay={this.handlePlay}\n                        onEnablePIP={this.handleEnablePIP}\n                        onDisablePIP={this.handleDisablePIP}\n                        onPause={this.handlePause}\n                        onBuffer={() => console.log('onBuffer')}\n                        onSeek={e => console.log('onSeek', e)}\n                        onEnded={this.handleEnded}\n                        onError={this.handleError}\n                        onProgress={this.handleProgress}\n                        onDuration={this.handleDuration}\n                        config={{\n                            youtube: {\n                                playerVars: {\n                                    showinfo: 1,\n                                    // disablekb: 1,\n                                    iv_load_policy: 3,\n                                    modestbranding: 1,\n                                    rel: 0\n                                }\n                            }\n                        }}\n                    />\n\n                    <Toolbar\n                        currentlyPlaying={this.state.currentlyPlaying}\n                        setCurrentlyPlaying={this.setCurrentlyPlayingPublic}\n                        playlist={this.state.playlist}\n                        setPlaylist={this.setPlaylist}\n                        handlePrevious={this.handlePrevious}\n                        handleNext={this.handleNext}\n                        notify={this.notify}\n                    ></Toolbar>\n                    <FlashMessage duration={50000} persistOnHover={true}>\n                        <p>{this.state.message.mainMessage}</p>\n                        <p className=\"color-text\">\n                            {this.state.message.colorMessage}\n                        </p>\n                    </FlashMessage>\n                </div>\n            </div>\n        )\n    }\n}\n\nexport default hot(module)(App)\n","/Users/kaybanks/Repository/videoplayer/src/index.js",[],{"ruleId":"18","severity":1,"message":"19","line":11,"column":8,"nodeType":"20","messageId":"21","endLine":11,"endColumn":16},{"ruleId":"18","severity":1,"message":"22","line":15,"column":8,"nodeType":"20","messageId":"21","endLine":15,"endColumn":14},{"ruleId":"18","severity":1,"message":"23","line":812,"column":13,"nodeType":"20","messageId":"21","endLine":812,"endColumn":19},{"ruleId":"18","severity":1,"message":"24","line":813,"column":13,"nodeType":"20","messageId":"21","endLine":813,"endColumn":19},{"ruleId":"18","severity":1,"message":"25","line":814,"column":13,"nodeType":"20","messageId":"21","endLine":814,"endColumn":21},{"ruleId":"18","severity":1,"message":"26","line":819,"column":15,"nodeType":"20","messageId":"21","endLine":819,"endColumn":24},{"ruleId":"18","severity":1,"message":"27","line":820,"column":15,"nodeType":"20","messageId":"21","endLine":820,"endColumn":29},"no-unused-vars","'Duration' is defined but never used.","Identifier","unusedVar","'Volume' is defined but never used.","'played' is assigned a value but never used.","'loaded' is assigned a value but never used.","'duration' is assigned a value but never used.","'SEPARATOR' is assigned a value but never used.","'turnOffSection' is assigned a value but never used."]